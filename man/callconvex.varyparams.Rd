% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calljulia.R
\name{callconvex.varyparams}
\alias{callconvex.varyparams}
\title{Simple R interface to Convex.jl to solve sequence of problems}
\usage{
callconvex.varyparams(opt.vars, pr.def, const.vars, vary.param, opt.var.names,
  pr.solve = "solve!(pr)", code.before = "", code.after = "",
  norun = FALSE, julia.call = "julia", delete.temp = TRUE)
}
\arguments{
\item{opt.vars}{string of code to declare optimization variables}

\item{pr.def}{string of code defining a problem called \code{pr}}

\item{const.vars}{list of non-optimization variables used in expression.
Labels of list elements should be the names of the variables.}

\item{vary.param}{list with a single vector or matrix (with a name). E.g.
list(lam=c(0.1, 1, 2)). This is a non-optimization variable used in CVX
expression that you want varied. If a vector, then each element is a
parameter; if a matrix, then each column is a vector-parameter. The problem
will be solved at each such level.}

\item{opt.var.names}{array of names of optimization variables to return.}

\item{pr.solve}{string of code for solving problem \code{pr}. This can be
to specify the solver used, for example.}

\item{code.before}{optional string of julia code to run before solving
problems}

\item{code.after}{optional string of julia code to run after solving
problems}

\item{norun}{Default FALSE.  Mostly for debugging purposes.  Returns the
command that would be run in julia without it actually opening julia.}

\item{julia.call}{How julia can be invoked through the \code{system} command.
Default: "julia". However, even if this is the alias in your default shell,
\code{system} might use a different shell in which "julia" is not
recognized. For example, in OS X this might be something like
"/Applications/Julia-0.3.3.app/Contents/Resources/julia/bin/julia"}

\item{delete.temp}{Default TRUE.  Indicates whether the temporary files that
are created should be deleted.}
}
\value{
Returns \code{optval} and \code{status} from Convex.jl in addition to
  optimal values of variables named in \code{opt.var.names}.  If optimization
  variable is a vector, then returns a matrix in which each column
  corresponds to a solution; if optimization variable is a matrix, then each
  returns a 3-dimensional array whose third mode corresponds to different
  solutions.
}
\description{
Like \code{\link{callconvex}} but allows a sequence of problems to be
performed that are identical except that a single parameter is varied. The
parameter varied can be scalar or vector valued.
}
\details{
This function uses \code{\link{calljulia}}.
}
\examples{
\dontrun{
set.seed(123)
n <- 200; p <- 50
x  <- matrix(rnorm(n * p), n, p)
beta <- rnorm(p)
y <- x \%*\% beta + 0.1 * rnorm(n)
julia <- "/Applications/Julia-0.3.3.app/Contents/Resources/julia/bin/julia"
# vary lambda for the lasso (with an unpenalized intercept)
pr.def <- "pr = minimize(sumsquares(y - b0 - x * b) + lam * norm(b, 1))"
opt.vars <- "b = Variable(p); b0 = Variable(1)"
lasso <- callconvex.varyparams(opt.vars = opt.vars, pr.def = pr.def,
                              const.vars = list(x = x, y = y, p = p),
                              vary.param = list(lam = seq(9, 2, length=10)),
                              opt.var.names = c("b", "b0"),
                              julia.call = julia)
}
}
\references{
Udell, Madeleine, et al. "Convex optimization in Julia." Proceedings of the
 1st First Workshop for High Performance Technical Computing in Dynamic
 Languages. IEEE Press, 2014.

Convex.jl julia package. \url{https://github.com/cvxgrp/Convex.jl}

Grant, Michael, Stephen Boyd, and Yinyu Ye. Disciplined convex programming.
Springer US, 2006.
}
\seealso{
\code{\link{callconvex}}
}
